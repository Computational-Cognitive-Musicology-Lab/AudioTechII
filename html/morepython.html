<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- <link rel="shortcut icon" href="Home/rabbit.ico"> -->
    <link rel="stylesheet" href="../css/lecturepage.css">
    <link rel="stylesheet" href="../css/prism.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/highlight.min.js"></script>
    <title>Audio Tech II | More Python and Numpy</title>
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>



<body>
    <script src="../javascripts/prism.js"></script>
    <div class="full-box">
        <a id="top"></a>

        <div class="nav-bar">
            <a href="../index.html">Home</a>
            <div class="dropdown">
                <button class="dropbtn">Lectures
                    <i class="fa fa-caret-down"></i>
                </button>
                <div class="dropdown-content">
                    <a href="../lectures/DSP.html">DSP</a>
                    <a href="../lectures/Statistics.html">Statistics</a>
                </div>
            </div>
            <a href="../coding/coding.html">Coding</a>
            <a href="../interaction/interaction.html">Interaction</a>
            <a href="../info/info.html">Information</a>
        </div>

        <div class="description">
            <h1>Python logicals, arrays, indexing, and functions</h1>
            <div class="colab-link">
                <a
                    href="https://colab.research.google.com/github/JiayingLi0803/AudioTechII_GRA/blob/main/notebooks/Lesson3_morePythonAndNumpy.ipynb">
                    Click to run the codes in Google colab.
                </a>
            </div>
            <h2>Boolean values and expressions</h2>
            <p>A <strong>boolean value</strong> is either true or false. It is named after the British mathematician, George Boole, who first formulated Boolean algebra. This is the basis of all modern computer logic.</p>
            <p>In Python, the two Boolean values are <code>True</code> and <code>False</code> (the capitalization must be exactly as shown), and the Python type is bool.</p>
            <pre class="language-python">
                <code class="language-python">
        type(True)
                </code>
            </pre>
            <code>bool</code>
            <pre class="language-python">
                <code class="language-python">
        type(TRUE)
                </code>
            </pre>
            <code>NameError: name 'TRUE' is not defined</code>
            <p>A Boolean <i>expression</i> is an expression that evaluates the input and produces a result which is a Boolean value. For example, the operator <code>==</code>  tests if two values are equal. It produces (or yields) a Boolean value:</p>
            <p>Usually, boolean expressions contain "comparison" (or "relational") operators.  </p>
            <p>Here are six common comparison operators which all produce a bool result:</p>
            <p><code>x == y</code>  &ensp;             # Produces <code>True</code> if ... x is equal to y  </p>
            <p><code>x != y</code>  &ensp;             # ... x is not equal to y  </p>
            <p><code>x  > y</code>  &ensp;             # ... x is greater than y  </p>
            <p><code>x  < y</code>  &ensp;              # ... x is less than y </p>
            <p><code>x >= y</code>  &ensp;             # ... x is greater than or equal to y </p>
            <p><code>x <= y</code>  &ensp;             # ... x is less than or equal to y </p>
            <h2>Logical operators</h2>
            <p>There are three logical operators, <code>and</code>, <code>or</code>, and <code>not</code>, that allow us to build more complex Boolean expressions from simpler Boolean expressions. The meaning of these operators is similar to their meaning in English. For example, <code>x > 0</code> and <code>x < 10</code> produces <code>True</code> only if x is greater than 0 and at the same time, x is less than 10.</p>
            <p><code>n % 2 == 0 or n % 3 == 0</code> is True if either of the conditions is True, that is, if the number n is divisible by 2 or it is divisible by 3. (What do you think happens if n is divisible by both 2 and by 3 at the same time? Will the expression yield True or False? Try it in your Python interpreter.)</p>
            <p>Finally, the <code>not</code> operator negates a Boolean value, so <code>not (x > y)</code> is <code>True</code> if (x > y) is False, that is, if x is less than or equal to y.</p>
            <p>The expression on the left of the or operator is evaluated first: if the result is True, Python does not (and need not) evaluate the expression on the right â€” this is called short-circuit evaluation. Similarly, for the <code>and</code> operator, if the expression on the left yields False, Python does not evaluate the expression on the right.</p>
            <p>This avoids unnecessary evaluations.</p>
            <pre class="language-python">
                <code class="language-python">
        #Boolean Example
        x = 10
        y = 1
        (3 > y) and (x < 20)
                </code>
            </pre>
            <code>True</code>
            <h2>Logic in Numpy</h2>
            <p>We know we can apply most mathematical functions and they'll be applied element-wise across numpy arrays. Like this:</p>
            <pre class="language-python">
                <code class="language-python">
        import numpy as np
        x = np.array([4,2,3])
        y = np.array([1,5,6])
        
        x + y
                </code>
            </pre>
            <code>array([5, 7, 9])</code>
            <p>However, often we may want to evaluate across multiple np.arrays to look for the position where both elements are <code>True</code>.</p>
            <pre class="language-python">
                <code class="language-python">
        # With LISTS:
        mylist1 = [True,  True,  False]  
        mylist2 = [False, True, True]  
        
        mylist1 and mylist2
        #This will simply return the second list.
                </code>
            </pre>
            <code>[False, True, True]</code>
            <pre class="language-python">
                <code class="language-python">
        #Now we'll convert to numpy arrays and try again:
        np.array(mylist1) and np.array(mylist2) 
        '''
        this will give an error, since it is trying to determine a single "true" or "false" for the whole array, 
        and unlike lists (which are "True" by virtue of being non-empty) they have no default "truth value."
        '''
                </code>
            </pre>
            <code>ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()</code>
            <p>So to write boolean expressions with numpy arrays, we have two options. Technically, you can use a bitwise operator (i.e., <code>&</code>, <code>|</code>). Computer scientists among you might argue that this isn't entirely appropriate, but it works, as shown below:</p>
            <pre class="language-python">
                <code class="language-python">
        np.array(mylist1) & np.array(mylist2) 
                </code>
            </pre>
            <code>array([False,  True, False])</code>
            <p>The other alternative (and the "technically correct" way of evalutating) is to use numpy's "logical_and" function:</p>
            <pre class="language-python">
                <code class="language-python">
        np.logical_and(np.array(mylist1), np.array(mylist2))
                </code>
            </pre>
            <code>array([False,  True, False])</code>
            <h2>Indexing with boolean (i.e. "fancy indexing")</h2>
            <p>Let's start by applying a boolean expression to a made-up numpy array:</p>
            <pre class="language-python">
                <code class="language-python">
        A = np.array([4, 7, 3, 4, 2, 8])
        A == 4
                </code>
            </pre>
            <code>array([ True, False, False,  True, False, False])</code>
            <p>Now we'll apply those boolean values to *index* an entirely different array. We will index an array, B, in the following example by using a Boolean mask. It is called "fancy indexing" if arrays are indexed by passing an array of indices to access multiple array elements at once. </p>
            <pre class="language-python">
                <code class="language-python">
        B = np.array([1,2,3,4,5,6])
        B[A == 4] # Returns elements of B at index values from A where those values are equal to 4.
                </code>
            </pre>
            <code>array([1, 4])</code>
            <p>Do you think this will work if the arrays are of different lengths? Try it yourself first.</p>
            <pre class="language-python">
                <code class="language-python">
        C = np.array([1,2,3,4,5,6,7]) # doesn't when array to be indexed is longer than the mask
        C[A == 4]
                </code>
            </pre>
            <code>IndexError: boolean index did not match indexed array along dimension 0; dimension is 7 but corresponding boolean dimension is 6</code>
            <pre class="language-python">
                <code class="language-python">
        C = np.array([1,2,3,4]) # nor when array to be indexed is shorter than the mask.
        C[A == 4]
                </code>
            </pre>
            <code>IndexError: boolean index did not match indexed array along dimension 0; dimension is 4 but corresponding boolean dimension is 6</code>
            <h2>Replacement</h2>
            <p>After using boolean operations to find elements matching some criteria, we may want to replace those values. We can do this like so:</p>
            <pre class="language-python">
                <code class="language-python">
        B[A == 4] = 100
        B
                </code>
            </pre>
            <code>array([100,   2,   3, 100,   5,   6])</code>
            <p>Notice this permanently changes the variable "B". Be careful to make a copy of your variable in case you don't wish to overwrite it! (like this: np.copy(var)). </p>




            <div class="footer">
            <a href="#top">Back to top</a>
        </div>


    </div>






</body>



</html>